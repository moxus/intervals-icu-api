/* tslint:disable */
/* eslint-disable */
/**
 * Intervals.icu API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Activity,
  DeleteEventsResponse,
  DoomedEvent,
  DuplicateEventsDTO,
  Event,
  EventEx,
} from '../models/index';
import {
    ActivityFromJSON,
    ActivityToJSON,
    DeleteEventsResponseFromJSON,
    DeleteEventsResponseToJSON,
    DoomedEventFromJSON,
    DoomedEventToJSON,
    DuplicateEventsDTOFromJSON,
    DuplicateEventsDTOToJSON,
    EventFromJSON,
    EventToJSON,
    EventExFromJSON,
    EventExToJSON,
} from '../models/index';

export interface CreateEventRequest {
    id: string;
    eventEx: EventEx;
}

export interface CreateMultipleEventsRequest {
    id: string;
    eventEx: Array<EventEx>;
    upsert?: boolean;
}

export interface DeleteEventRequest {
    id: string;
    eventId: number;
    others?: boolean;
    notBefore?: string;
}

export interface DeleteEventsRequest {
    id: string;
    oldest: string;
    category: Array<string>;
    newest?: string;
    createdById?: string;
}

export interface DeleteEventsBulkRequest {
    id: string;
    doomedEvent: Array<DoomedEvent>;
}

export interface DownloadWorkout1Request {
    id: string;
    eventId: number;
    ext: string;
}

export interface DownloadWorkoutsRequest {
    id: string;
    ext: string;
    oldest: string;
    newest: string;
    powerRange?: number;
    hrRange?: number;
    paceRange?: number;
    locale?: string;
}

export interface DuplicateEventsRequest {
    id: string;
    duplicateEventsDTO: DuplicateEventsDTO;
}

export interface ListEventsRequest {
    id: string;
    format: string;
    oldest: string;
    newest: string;
    calendarId?: number;
    ext?: string;
    powerRange?: number;
    hrRange?: number;
    paceRange?: number;
    locale?: string;
    resolve?: boolean;
}

export interface ListFitnessModelEventsRequest {
    id: string;
}

export interface ListTags1Request {
    id: string;
}

export interface MarkEventAsDoneRequest {
    id: string;
    eventId: number;
}

export interface ShowEventRequest {
    id: string;
    eventId: number;
}

export interface UpdateEventRequest {
    id: string;
    eventId: number;
    eventEx: EventEx;
}

export interface UpdateEventsRequest {
    id: string;
    oldest: string;
    newest: string;
    event: Event;
}

/**
 * 
 */
export class EventsApi extends runtime.BaseAPI {

    /**
     * This endpoint accepts workouts in native Intervals.icu format (\'description\' field) as well as zwo, mrc, erg and fit files (use \'file_contents\' or \'file_contents_base64\')
     * Create an event on the athlete\'s calendar
     */
    async createEventRaw(requestParameters: CreateEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Event>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createEvent().'
            );
        }

        if (requestParameters['eventEx'] == null) {
            throw new runtime.RequiredError(
                'eventEx',
                'Required parameter "eventEx" was null or undefined when calling createEvent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EventExToJSON(requestParameters['eventEx']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventFromJSON(jsonValue));
    }

    /**
     * This endpoint accepts workouts in native Intervals.icu format (\'description\' field) as well as zwo, mrc, erg and fit files (use \'file_contents\' or \'file_contents_base64\')
     * Create an event on the athlete\'s calendar
     */
    async createEvent(requestParameters: CreateEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Event> {
        const response = await this.createEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint accepts workouts in native Intervals.icu format (\'description\' field) as well as zwo, mrc, erg and fit files (use \'file_contents\' or \'file_contents_base64\')
     * Create multiple events on the athlete\'s calendar
     */
    async createMultipleEventsRaw(requestParameters: CreateMultipleEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createMultipleEvents().'
            );
        }

        if (requestParameters['eventEx'] == null) {
            throw new runtime.RequiredError(
                'eventEx',
                'Required parameter "eventEx" was null or undefined when calling createMultipleEvents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['upsert'] != null) {
            queryParameters['upsert'] = requestParameters['upsert'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/bulk`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['eventEx']!.map(EventExToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * This endpoint accepts workouts in native Intervals.icu format (\'description\' field) as well as zwo, mrc, erg and fit files (use \'file_contents\' or \'file_contents_base64\')
     * Create multiple events on the athlete\'s calendar
     */
    async createMultipleEvents(requestParameters: CreateMultipleEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Event>> {
        const response = await this.createMultipleEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an event from an athlete\'s calendar
     */
    async deleteEventRaw(requestParameters: DeleteEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteEvent().'
            );
        }

        if (requestParameters['eventId'] == null) {
            throw new runtime.RequiredError(
                'eventId',
                'Required parameter "eventId" was null or undefined when calling deleteEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['others'] != null) {
            queryParameters['others'] = requestParameters['others'];
        }

        if (requestParameters['notBefore'] != null) {
            queryParameters['notBefore'] = requestParameters['notBefore'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/{eventId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters['eventId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete an event from an athlete\'s calendar
     */
    async deleteEvent(requestParameters: DeleteEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: object; }> {
        const response = await this.deleteEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a range of events from the athlete\'s calendar
     */
    async deleteEventsRaw(requestParameters: DeleteEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteEvents().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling deleteEvents().'
            );
        }

        if (requestParameters['category'] == null) {
            throw new runtime.RequiredError(
                'category',
                'Required parameter "category" was null or undefined when calling deleteEvents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['createdById'] != null) {
            queryParameters['createdById'] = requestParameters['createdById'];
        }

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a range of events from the athlete\'s calendar
     */
    async deleteEvents(requestParameters: DeleteEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEventsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete events by id or by external_id. If external_id is supplied then the event must have been created by the calling OAuth application. If both id and external_id are supplied then external_id is used. Events that do not exist are ignored.
     * Delete events from an athlete\'s calendar by id or external_id
     */
    async deleteEventsBulkRaw(requestParameters: DeleteEventsBulkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteEventsResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteEventsBulk().'
            );
        }

        if (requestParameters['doomedEvent'] == null) {
            throw new runtime.RequiredError(
                'doomedEvent',
                'Required parameter "doomedEvent" was null or undefined when calling deleteEventsBulk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/bulk-delete`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['doomedEvent']!.map(DoomedEventToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteEventsResponseFromJSON(jsonValue));
    }

    /**
     * Delete events by id or by external_id. If external_id is supplied then the event must have been created by the calling OAuth application. If both id and external_id are supplied then external_id is used. Events that do not exist are ignored.
     * Delete events from an athlete\'s calendar by id or external_id
     */
    async deleteEventsBulk(requestParameters: DeleteEventsBulkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteEventsResponse> {
        const response = await this.deleteEventsBulkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a planned workout in zwo, mrc, erg or fit format
     */
    async downloadWorkout1Raw(requestParameters: DownloadWorkout1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadWorkout1().'
            );
        }

        if (requestParameters['eventId'] == null) {
            throw new runtime.RequiredError(
                'eventId',
                'Required parameter "eventId" was null or undefined when calling downloadWorkout1().'
            );
        }

        if (requestParameters['ext'] == null) {
            throw new runtime.RequiredError(
                'ext',
                'Required parameter "ext" was null or undefined when calling downloadWorkout1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/{eventId}/download{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters['eventId']))).replace(`{${"ext"}}`, encodeURIComponent(String(requestParameters['ext']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download a planned workout in zwo, mrc, erg or fit format
     */
    async downloadWorkout1(requestParameters: DownloadWorkout1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadWorkout1Raw(requestParameters, initOverrides);
    }

    /**
     * Download one or more workouts from the athlete\'s calendar in a zip file
     */
    async downloadWorkoutsRaw(requestParameters: DownloadWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadWorkouts().'
            );
        }

        if (requestParameters['ext'] == null) {
            throw new runtime.RequiredError(
                'ext',
                'Required parameter "ext" was null or undefined when calling downloadWorkouts().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling downloadWorkouts().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling downloadWorkouts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ext'] != null) {
            queryParameters['ext'] = requestParameters['ext'];
        }

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['powerRange'] != null) {
            queryParameters['powerRange'] = requestParameters['powerRange'];
        }

        if (requestParameters['hrRange'] != null) {
            queryParameters['hrRange'] = requestParameters['hrRange'];
        }

        if (requestParameters['paceRange'] != null) {
            queryParameters['paceRange'] = requestParameters['paceRange'];
        }

        if (requestParameters['locale'] != null) {
            queryParameters['locale'] = requestParameters['locale'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts.zip`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download one or more workouts from the athlete\'s calendar in a zip file
     */
    async downloadWorkouts(requestParameters: DownloadWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadWorkoutsRaw(requestParameters, initOverrides);
    }

    /**
     * Duplicate one or more events on the athlete\'s calendar
     */
    async duplicateEventsRaw(requestParameters: DuplicateEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling duplicateEvents().'
            );
        }

        if (requestParameters['duplicateEventsDTO'] == null) {
            throw new runtime.RequiredError(
                'duplicateEventsDTO',
                'Required parameter "duplicateEventsDTO" was null or undefined when calling duplicateEvents().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/duplicate-events`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DuplicateEventsDTOToJSON(requestParameters['duplicateEventsDTO']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Duplicate one or more events on the athlete\'s calendar
     */
    async duplicateEvents(requestParameters: DuplicateEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Event>> {
        const response = await this.duplicateEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List events (planned workouts, notes etc.) on the athlete\'s calendar, add .csv for CSV output
     */
    async listEventsRaw(requestParameters: ListEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listEvents().'
            );
        }

        if (requestParameters['format'] == null) {
            throw new runtime.RequiredError(
                'format',
                'Required parameter "format" was null or undefined when calling listEvents().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling listEvents().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling listEvents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['calendarId'] != null) {
            queryParameters['calendar_id'] = requestParameters['calendarId'];
        }

        if (requestParameters['ext'] != null) {
            queryParameters['ext'] = requestParameters['ext'];
        }

        if (requestParameters['powerRange'] != null) {
            queryParameters['powerRange'] = requestParameters['powerRange'];
        }

        if (requestParameters['hrRange'] != null) {
            queryParameters['hrRange'] = requestParameters['hrRange'];
        }

        if (requestParameters['paceRange'] != null) {
            queryParameters['paceRange'] = requestParameters['paceRange'];
        }

        if (requestParameters['locale'] != null) {
            queryParameters['locale'] = requestParameters['locale'];
        }

        if (requestParameters['resolve'] != null) {
            queryParameters['resolve'] = requestParameters['resolve'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events{format}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"format"}}`, encodeURIComponent(String(requestParameters['format']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * List events (planned workouts, notes etc.) on the athlete\'s calendar, add .csv for CSV output
     */
    async listEvents(requestParameters: ListEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Event>> {
        const response = await this.listEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * These have category FITNESS_DAYS (days for fitness and fatigue), SET_FITNESS (set starting fitness and fatigue) and SET_EFTP (set eFTP)
     * List events that influence the athlete\'s fitness calculation in ascending date order
     */
    async listFitnessModelEventsRaw(requestParameters: ListFitnessModelEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listFitnessModelEvents().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/fitness-model-events`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * These have category FITNESS_DAYS (days for fitness and fatigue), SET_FITNESS (set starting fitness and fatigue) and SET_EFTP (set eFTP)
     * List events that influence the athlete\'s fitness calculation in ascending date order
     */
    async listFitnessModelEvents(requestParameters: ListFitnessModelEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Event>> {
        const response = await this.listFitnessModelEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all tags that have been applied to events on the athlete\'s calendar
     */
    async listTags1Raw(requestParameters: ListTags1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listTags1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/event-tags`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List all tags that have been applied to events on the athlete\'s calendar
     */
    async listTags1(requestParameters: ListTags1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.listTags1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a manual activity to match a planned workout
     */
    async markEventAsDoneRaw(requestParameters: MarkEventAsDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Activity>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling markEventAsDone().'
            );
        }

        if (requestParameters['eventId'] == null) {
            throw new runtime.RequiredError(
                'eventId',
                'Required parameter "eventId" was null or undefined when calling markEventAsDone().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/{eventId}/mark-done`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters['eventId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivityFromJSON(jsonValue));
    }

    /**
     * Create a manual activity to match a planned workout
     */
    async markEventAsDone(requestParameters: MarkEventAsDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Activity> {
        const response = await this.markEventAsDoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an event
     */
    async showEventRaw(requestParameters: ShowEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Event>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling showEvent().'
            );
        }

        if (requestParameters['eventId'] == null) {
            throw new runtime.RequiredError(
                'eventId',
                'Required parameter "eventId" was null or undefined when calling showEvent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/{eventId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters['eventId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventFromJSON(jsonValue));
    }

    /**
     * Get an event
     */
    async showEvent(requestParameters: ShowEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Event> {
        const response = await this.showEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an event
     */
    async updateEventRaw(requestParameters: UpdateEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateEvent().'
            );
        }

        if (requestParameters['eventId'] == null) {
            throw new runtime.RequiredError(
                'eventId',
                'Required parameter "eventId" was null or undefined when calling updateEvent().'
            );
        }

        if (requestParameters['eventEx'] == null) {
            throw new runtime.RequiredError(
                'eventEx',
                'Required parameter "eventEx" was null or undefined when calling updateEvent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events/{eventId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters['eventId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EventExToJSON(requestParameters['eventEx']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update an event
     */
    async updateEvent(requestParameters: UpdateEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update all events for a date range at once. Only hide_from_athlete and athlete_cannot_edit can be updated
     */
    async updateEventsRaw(requestParameters: UpdateEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateEvents().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling updateEvents().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling updateEvents().'
            );
        }

        if (requestParameters['event'] == null) {
            throw new runtime.RequiredError(
                'event',
                'Required parameter "event" was null or undefined when calling updateEvents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/events`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EventToJSON(requestParameters['event']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Update all events for a date range at once. Only hide_from_athlete and athlete_cannot_edit can be updated
     */
    async updateEvents(requestParameters: UpdateEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Event>> {
        const response = await this.updateEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
