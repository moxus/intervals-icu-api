/* tslint:disable */
/* eslint-disable */
/**
 * Intervals.icu API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateFolderDTO,
  DuplicateWorkoutsDTO,
  Folder,
  SharedWith,
  UploadWellnessRequest,
  Workout,
  WorkoutEx,
} from '../models/index';
import {
    CreateFolderDTOFromJSON,
    CreateFolderDTOToJSON,
    DuplicateWorkoutsDTOFromJSON,
    DuplicateWorkoutsDTOToJSON,
    FolderFromJSON,
    FolderToJSON,
    SharedWithFromJSON,
    SharedWithToJSON,
    UploadWellnessRequestFromJSON,
    UploadWellnessRequestToJSON,
    WorkoutFromJSON,
    WorkoutToJSON,
    WorkoutExFromJSON,
    WorkoutExToJSON,
} from '../models/index';

export interface ApplyCurrentPlanChangesRequest {
    id: string;
}

export interface CreateFolderRequest {
    id: string;
    createFolderDTO: CreateFolderDTO;
}

export interface CreateMultipleWorkoutsRequest {
    id: string;
    workoutEx: Array<WorkoutEx>;
}

export interface CreateWorkoutRequest {
    id: string;
    workoutEx: WorkoutEx;
}

export interface DeleteFolderRequest {
    id: string;
    folderId: number;
}

export interface DeleteWorkoutRequest {
    id: string;
    workoutId: number;
    others?: boolean;
}

export interface DownloadWorkoutRequest {
    ext: string;
    workout: Workout;
}

export interface DownloadWorkoutForAthleteRequest {
    id: string;
    ext: string;
    workout: Workout;
}

export interface DuplicateWorkoutsRequest {
    id: string;
    duplicateWorkoutsDTO: DuplicateWorkoutsDTO;
}

export interface ImportWorkoutFileRequest {
    id: string;
    folderId: number;
    type: ImportWorkoutFileTypeEnum;
    athleteId?: string;
    uploadWellnessRequest?: UploadWellnessRequest;
}

export interface ListFolderSharedWithRequest {
    id: string;
    folderId: number;
}

export interface ListFoldersRequest {
    id: string;
}

export interface ListTagsRequest {
    id: string;
}

export interface ListWorkoutsRequest {
    id: string;
}

export interface ShowWorkoutRequest {
    id: string;
    workoutId: number;
}

export interface UpdateFolderRequest {
    id: string;
    folderId: number;
    folder: Folder;
}

export interface UpdateFolderSharedWithRequest {
    id: string;
    folderId: number;
    sharedWith: Array<SharedWith>;
}

export interface UpdatePlanWorkoutsRequest {
    id: string;
    folderId: number;
    oldest: number;
    newest: number;
    workout: Workout;
}

export interface UpdateWorkoutRequest {
    id: string;
    workoutId: number;
    workoutEx: WorkoutEx;
}

/**
 * 
 */
export class LibraryApi extends runtime.BaseAPI {

    /**
     * Only workouts from today or in the future are updated
     * Apply any changes from the athlete\'s current plan to the athlete\'s calendar
     */
    async applyCurrentPlanChangesRaw(requestParameters: ApplyCurrentPlanChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling applyCurrentPlanChanges().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/apply-plan-changes`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Only workouts from today or in the future are updated
     * Apply any changes from the athlete\'s current plan to the athlete\'s calendar
     */
    async applyCurrentPlanChanges(requestParameters: ApplyCurrentPlanChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: object; }> {
        const response = await this.applyCurrentPlanChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new workout folder or plan
     */
    async createFolderRaw(requestParameters: CreateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createFolder().'
            );
        }

        if (requestParameters['createFolderDTO'] == null) {
            throw new runtime.RequiredError(
                'createFolderDTO',
                'Required parameter "createFolderDTO" was null or undefined when calling createFolder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFolderDTOToJSON(requestParameters['createFolderDTO']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Create a new workout folder or plan
     */
    async createFolder(requestParameters: CreateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.createFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create multiple new workouts in a folder or plan in the athlete\'s workout library
     */
    async createMultipleWorkoutsRaw(requestParameters: CreateMultipleWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Workout>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createMultipleWorkouts().'
            );
        }

        if (requestParameters['workoutEx'] == null) {
            throw new runtime.RequiredError(
                'workoutEx',
                'Required parameter "workoutEx" was null or undefined when calling createMultipleWorkouts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts/bulk`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['workoutEx']!.map(WorkoutExToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkoutFromJSON));
    }

    /**
     * Create multiple new workouts in a folder or plan in the athlete\'s workout library
     */
    async createMultipleWorkouts(requestParameters: CreateMultipleWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Workout>> {
        const response = await this.createMultipleWorkoutsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint accepts workouts in native Intervals.icu format (\'description\' field) as well as zwo, mrc, erg and fit files (use \'file_contents\' or \'file_contents_base64\')
     * Create a new workout in a folder or plan in the athlete\'s workout library
     */
    async createWorkoutRaw(requestParameters: CreateWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Workout>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createWorkout().'
            );
        }

        if (requestParameters['workoutEx'] == null) {
            throw new runtime.RequiredError(
                'workoutEx',
                'Required parameter "workoutEx" was null or undefined when calling createWorkout().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkoutExToJSON(requestParameters['workoutEx']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkoutFromJSON(jsonValue));
    }

    /**
     * This endpoint accepts workouts in native Intervals.icu format (\'description\' field) as well as zwo, mrc, erg and fit files (use \'file_contents\' or \'file_contents_base64\')
     * Create a new workout in a folder or plan in the athlete\'s workout library
     */
    async createWorkout(requestParameters: CreateWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Workout> {
        const response = await this.createWorkoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a workout folder or plan including all workouts
     */
    async deleteFolderRaw(requestParameters: DeleteFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteFolder().'
            );
        }

        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling deleteFolder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders/{folderId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"folderId"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete a workout folder or plan including all workouts
     */
    async deleteFolder(requestParameters: DeleteFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: object; }> {
        const response = await this.deleteFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the ids of the deleted workout(s)
     * Delete a workout (and optionally others added at the same time if the workout is on a plan)
     */
    async deleteWorkoutRaw(requestParameters: DeleteWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteWorkout().'
            );
        }

        if (requestParameters['workoutId'] == null) {
            throw new runtime.RequiredError(
                'workoutId',
                'Required parameter "workoutId" was null or undefined when calling deleteWorkout().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['others'] != null) {
            queryParameters['others'] = requestParameters['others'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts/{workoutId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"workoutId"}}`, encodeURIComponent(String(requestParameters['workoutId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the ids of the deleted workout(s)
     * Delete a workout (and optionally others added at the same time if the workout is on a plan)
     */
    async deleteWorkout(requestParameters: DeleteWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.deleteWorkoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The athlete to use is extracted from the bearer token and used to resolve power targets etc.. Note that the create workout endpoint can convert workouts and might be more convenient.
     * Convert a workout to .zwo (Zwift), .mrc, .erg or .fit
     */
    async downloadWorkoutRaw(requestParameters: DownloadWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['ext'] == null) {
            throw new runtime.RequiredError(
                'ext',
                'Required parameter "ext" was null or undefined when calling downloadWorkout().'
            );
        }

        if (requestParameters['workout'] == null) {
            throw new runtime.RequiredError(
                'workout',
                'Required parameter "workout" was null or undefined when calling downloadWorkout().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/download-workout{ext}`.replace(`{${"ext"}}`, encodeURIComponent(String(requestParameters['ext']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkoutToJSON(requestParameters['workout']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The athlete to use is extracted from the bearer token and used to resolve power targets etc.. Note that the create workout endpoint can convert workouts and might be more convenient.
     * Convert a workout to .zwo (Zwift), .mrc, .erg or .fit
     */
    async downloadWorkout(requestParameters: DownloadWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadWorkoutRaw(requestParameters, initOverrides);
    }

    /**
     * The athlete\'s settings are used to resolve power targets etc.. Note that the create workout endpoint can convert workouts and might be more convenient.
     * Convert a workout to .zwo (Zwift), .mrc, .erg or .fit.
     */
    async downloadWorkoutForAthleteRaw(requestParameters: DownloadWorkoutForAthleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadWorkoutForAthlete().'
            );
        }

        if (requestParameters['ext'] == null) {
            throw new runtime.RequiredError(
                'ext',
                'Required parameter "ext" was null or undefined when calling downloadWorkoutForAthlete().'
            );
        }

        if (requestParameters['workout'] == null) {
            throw new runtime.RequiredError(
                'workout',
                'Required parameter "workout" was null or undefined when calling downloadWorkoutForAthlete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/download-workout{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"ext"}}`, encodeURIComponent(String(requestParameters['ext']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkoutToJSON(requestParameters['workout']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The athlete\'s settings are used to resolve power targets etc.. Note that the create workout endpoint can convert workouts and might be more convenient.
     * Convert a workout to .zwo (Zwift), .mrc, .erg or .fit.
     */
    async downloadWorkoutForAthlete(requestParameters: DownloadWorkoutForAthleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadWorkoutForAthleteRaw(requestParameters, initOverrides);
    }

    /**
     * Duplicate workouts on a plan
     */
    async duplicateWorkoutsRaw(requestParameters: DuplicateWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Workout>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling duplicateWorkouts().'
            );
        }

        if (requestParameters['duplicateWorkoutsDTO'] == null) {
            throw new runtime.RequiredError(
                'duplicateWorkoutsDTO',
                'Required parameter "duplicateWorkoutsDTO" was null or undefined when calling duplicateWorkouts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/duplicate-workouts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DuplicateWorkoutsDTOToJSON(requestParameters['duplicateWorkoutsDTO']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkoutFromJSON));
    }

    /**
     * Duplicate workouts on a plan
     */
    async duplicateWorkouts(requestParameters: DuplicateWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Workout>> {
        const response = await this.duplicateWorkoutsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create new workout from .zwo, .mrc, .erg or .fit file in a folder
     */
    async importWorkoutFileRaw(requestParameters: ImportWorkoutFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Workout>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling importWorkoutFile().'
            );
        }

        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling importWorkoutFile().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling importWorkoutFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['athleteId'] != null) {
            queryParameters['athleteId'] = requestParameters['athleteId'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders/{folderId}/import-workout`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"folderId"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UploadWellnessRequestToJSON(requestParameters['uploadWellnessRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkoutFromJSON(jsonValue));
    }

    /**
     * Create new workout from .zwo, .mrc, .erg or .fit file in a folder
     */
    async importWorkoutFile(requestParameters: ImportWorkoutFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Workout> {
        const response = await this.importWorkoutFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List athletes that the folder or plan has been shared with
     */
    async listFolderSharedWithRaw(requestParameters: ListFolderSharedWithRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SharedWith>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listFolderSharedWith().'
            );
        }

        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling listFolderSharedWith().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders/{folderId}/shared-with`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"folderId"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SharedWithFromJSON));
    }

    /**
     * List athletes that the folder or plan has been shared with
     */
    async listFolderSharedWith(requestParameters: ListFolderSharedWithRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SharedWith>> {
        const response = await this.listFolderSharedWithRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the athlete\'s folders, plans and workouts
     */
    async listFoldersRaw(requestParameters: ListFoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Folder>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listFolders().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FolderFromJSON));
    }

    /**
     * List all the athlete\'s folders, plans and workouts
     */
    async listFolders(requestParameters: ListFoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Folder>> {
        const response = await this.listFoldersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all tags that have been applied to workouts in the athlete\'s library
     */
    async listTagsRaw(requestParameters: ListTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listTags().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workout-tags`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List all tags that have been applied to workouts in the athlete\'s library
     */
    async listTags(requestParameters: ListTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.listTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the workouts in the athlete\'s library
     */
    async listWorkoutsRaw(requestParameters: ListWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Workout>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listWorkouts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkoutFromJSON));
    }

    /**
     * List all the workouts in the athlete\'s library
     */
    async listWorkouts(requestParameters: ListWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Workout>> {
        const response = await this.listWorkoutsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a workout
     */
    async showWorkoutRaw(requestParameters: ShowWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Workout>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling showWorkout().'
            );
        }

        if (requestParameters['workoutId'] == null) {
            throw new runtime.RequiredError(
                'workoutId',
                'Required parameter "workoutId" was null or undefined when calling showWorkout().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts/{workoutId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"workoutId"}}`, encodeURIComponent(String(requestParameters['workoutId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkoutFromJSON(jsonValue));
    }

    /**
     * Get a workout
     */
    async showWorkout(requestParameters: ShowWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Workout> {
        const response = await this.showWorkoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a workout folder or plan
     */
    async updateFolderRaw(requestParameters: UpdateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateFolder().'
            );
        }

        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling updateFolder().'
            );
        }

        if (requestParameters['folder'] == null) {
            throw new runtime.RequiredError(
                'folder',
                'Required parameter "folder" was null or undefined when calling updateFolder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders/{folderId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"folderId"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters['folder']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Update a workout folder or plan
     */
    async updateFolder(requestParameters: UpdateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.updateFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add/remove athletes from the share list for the folder
     */
    async updateFolderSharedWithRaw(requestParameters: UpdateFolderSharedWithRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SharedWith>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateFolderSharedWith().'
            );
        }

        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling updateFolderSharedWith().'
            );
        }

        if (requestParameters['sharedWith'] == null) {
            throw new runtime.RequiredError(
                'sharedWith',
                'Required parameter "sharedWith" was null or undefined when calling updateFolderSharedWith().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders/{folderId}/shared-with`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"folderId"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['sharedWith']!.map(SharedWithToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SharedWithFromJSON));
    }

    /**
     * Add/remove athletes from the share list for the folder
     */
    async updateFolderSharedWith(requestParameters: UpdateFolderSharedWithRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SharedWith>> {
        const response = await this.updateFolderSharedWithRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a range of workouts on a plan. Currently only hide_from_athlete can be changed
     */
    async updatePlanWorkoutsRaw(requestParameters: UpdatePlanWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Workout>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updatePlanWorkouts().'
            );
        }

        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling updatePlanWorkouts().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling updatePlanWorkouts().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling updatePlanWorkouts().'
            );
        }

        if (requestParameters['workout'] == null) {
            throw new runtime.RequiredError(
                'workout',
                'Required parameter "workout" was null or undefined when calling updatePlanWorkouts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/folders/{folderId}/workouts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"folderId"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: WorkoutToJSON(requestParameters['workout']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkoutFromJSON));
    }

    /**
     * Update a range of workouts on a plan. Currently only hide_from_athlete can be changed
     */
    async updatePlanWorkouts(requestParameters: UpdatePlanWorkoutsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Workout>> {
        const response = await this.updatePlanWorkoutsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a workout
     */
    async updateWorkoutRaw(requestParameters: UpdateWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Workout>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateWorkout().'
            );
        }

        if (requestParameters['workoutId'] == null) {
            throw new runtime.RequiredError(
                'workoutId',
                'Required parameter "workoutId" was null or undefined when calling updateWorkout().'
            );
        }

        if (requestParameters['workoutEx'] == null) {
            throw new runtime.RequiredError(
                'workoutEx',
                'Required parameter "workoutEx" was null or undefined when calling updateWorkout().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/workouts/{workoutId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"workoutId"}}`, encodeURIComponent(String(requestParameters['workoutId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: WorkoutExToJSON(requestParameters['workoutEx']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkoutFromJSON(jsonValue));
    }

    /**
     * Update a workout
     */
    async updateWorkout(requestParameters: UpdateWorkoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Workout> {
        const response = await this.updateWorkoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ImportWorkoutFileTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ImportWorkoutFileTypeEnum = typeof ImportWorkoutFileTypeEnum[keyof typeof ImportWorkoutFileTypeEnum];
