/* tslint:disable */
/* eslint-disable */
/**
 * Intervals.icu API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Activity,
  ActivityFilter,
  ActivityHRCurvePayload,
  ActivityId,
  ActivityPowerCurvePayload,
  ActivitySearchResult,
  ActivityStream,
  BestEfforts,
  Bucket,
  DataCurveSetHRCurve,
  DataCurveSetPaceCurve,
  DataCurveSetPowerCurve,
  GetActivityDefaultResponse,
  HRLoadModel,
  IcuSegment,
  Interval,
  IntervalsDTO,
  MapData,
  Plot,
  PowerHRCurve,
  PowerModel,
  PowerVsHRPlot,
  UploadResponse,
} from '../models/index';
import {
    ActivityFromJSON,
    ActivityToJSON,
    ActivityFilterFromJSON,
    ActivityFilterToJSON,
    ActivityHRCurvePayloadFromJSON,
    ActivityHRCurvePayloadToJSON,
    ActivityIdFromJSON,
    ActivityIdToJSON,
    ActivityPowerCurvePayloadFromJSON,
    ActivityPowerCurvePayloadToJSON,
    ActivitySearchResultFromJSON,
    ActivitySearchResultToJSON,
    ActivityStreamFromJSON,
    ActivityStreamToJSON,
    BestEffortsFromJSON,
    BestEffortsToJSON,
    BucketFromJSON,
    BucketToJSON,
    DataCurveSetHRCurveFromJSON,
    DataCurveSetHRCurveToJSON,
    DataCurveSetPaceCurveFromJSON,
    DataCurveSetPaceCurveToJSON,
    DataCurveSetPowerCurveFromJSON,
    DataCurveSetPowerCurveToJSON,
    GetActivityDefaultResponseFromJSON,
    GetActivityDefaultResponseToJSON,
    HRLoadModelFromJSON,
    HRLoadModelToJSON,
    IcuSegmentFromJSON,
    IcuSegmentToJSON,
    IntervalFromJSON,
    IntervalToJSON,
    IntervalsDTOFromJSON,
    IntervalsDTOToJSON,
    MapDataFromJSON,
    MapDataToJSON,
    PlotFromJSON,
    PlotToJSON,
    PowerHRCurveFromJSON,
    PowerHRCurveToJSON,
    PowerModelFromJSON,
    PowerModelToJSON,
    PowerVsHRPlotFromJSON,
    PowerVsHRPlotToJSON,
    UploadResponseFromJSON,
    UploadResponseToJSON,
} from '../models/index';

export interface CreateManualActivityRequest {
    id: string;
    activity: Activity;
}

export interface DeleteActivityRequest {
    id: string;
}

export interface DeleteIntervalsRequest {
    id: string;
    interval: Array<Interval>;
}

export interface DownloadActivitiesAsCSVRequest {
    id: string;
}

export interface DownloadActivityFileRequest {
    id: string;
}

export interface DownloadActivityFitFileRequest {
    id: string;
    power?: boolean;
    hr?: boolean;
}

export interface DownloadActivityFitFilesRequest {
    id: string;
    ids: Array<string>;
    power?: boolean;
    hr?: boolean;
}

export interface FindBestEffortsRequest {
    id: string;
    stream: string;
    duration?: number;
    distance?: number;
    count?: number;
    minValue?: number;
    excludeIntervals?: boolean;
    startIndex?: number;
    endIndex?: number;
}

export interface GetActivitiesRequest {
    athleteId: string;
    ids: Array<string>;
    intervals?: boolean;
}

export interface GetActivityRequest {
    id: string;
    intervals?: boolean;
}

export interface GetActivityHRCurveRequest {
    id: string;
}

export interface GetActivityMapRequest {
    id: string;
}

export interface GetActivityPaceCurveRequest {
    id: string;
    gap?: boolean;
}

export interface GetActivityPowerCurveRequest {
    id: string;
    fatigue?: string;
}

export interface GetActivityPowerSpikeModelRequest {
    id: string;
}

export interface GetActivitySegmentsRequest {
    id: string;
}

export interface GetActivityStreamsRequest {
    id: string;
    types?: Array<string>;
}

export interface GetAthleteMMPModelRequest {
    id: string;
    type: GetAthleteMMPModelTypeEnum;
}

export interface GetGapHistogramRequest {
    id: string;
}

export interface GetHRHistogramRequest {
    id: string;
    bucketSize?: number;
}

export interface GetHRTrainingLoadModelRequest {
    id: string;
}

export interface GetIntervalStatsRequest {
    id: string;
    startIndex: number;
    endIndex: number;
}

export interface GetIntervalsRequest {
    id: string;
}

export interface GetPaceHistogramRequest {
    id: string;
}

export interface GetPowerHRCurveRequest {
    id: string;
    start: string;
    end: string;
}

export interface GetPowerHistogramRequest {
    id: string;
    bucketSize?: number;
}

export interface GetPowerVsHRRequest {
    id: string;
}

export interface GetTimeAtHRRequest {
    id: string;
}

export interface ListActivitiesRequest {
    id: string;
    oldest: string;
    newest: string;
}

export interface ListActivityHRCurvesRequest {
    id: string;
    oldest: string;
    newest: string;
    filters?: Array<ActivityFilter>;
    secs?: Array<number>;
    type?: ListActivityHRCurvesTypeEnum;
}

export interface ListActivityPaceCurvesRequest {
    id: string;
    oldest: string;
    newest: string;
    type?: ListActivityPaceCurvesTypeEnum;
    filters?: Array<ActivityFilter>;
    distances?: Array<number>;
    gap?: boolean;
}

export interface ListActivityPowerCurvesRequest {
    id: string;
    oldest: string;
    newest: string;
    filters?: Array<ActivityFilter>;
    secs?: Array<number>;
    type?: ListActivityPowerCurvesTypeEnum;
    fatigue?: string;
}

export interface ListAthleteHRCurvesRequest {
    id: string;
    newest?: string;
    curves?: Array<string>;
    type?: ListAthleteHRCurvesTypeEnum;
    subMaxEfforts?: number;
    now?: string;
    filters?: Array<ActivityFilter>;
}

export interface ListAthletePaceCurvesRequest {
    id: string;
    newest?: string;
    curves?: Array<string>;
    type?: ListAthletePaceCurvesTypeEnum;
    includeRanks?: boolean;
    subMaxEfforts?: number;
    now?: string;
    gap?: boolean;
    pmType?: ListAthletePaceCurvesPmTypeEnum;
    filters?: Array<ActivityFilter>;
}

export interface ListAthletePowerCurvesRequest {
    id: string;
    type: ListAthletePowerCurvesTypeEnum;
    newest?: string;
    curves?: Array<string>;
    includeRanks?: boolean;
    subMaxEfforts?: number;
    now?: string;
    pmType?: ListAthletePowerCurvesPmTypeEnum;
    filters?: Array<ActivityFilter>;
}

export interface ListTags2Request {
    id: string;
}

export interface SearchForActivitiesRequest {
    id: string;
    q: string;
    limit?: number;
}

export interface SearchForActivitiesFullRequest {
    id: string;
    q: string;
    limit?: number;
}

export interface SearchForIntervalsRequest {
    id: string;
    minSecs: number;
    maxSecs: number;
    minIntensity: number;
    maxIntensity: number;
    type?: SearchForIntervalsTypeEnum;
    minReps?: number;
    maxReps?: number;
    limit?: number;
}

export interface SplitIntervalRequest {
    id: string;
    splitAt: number;
}

export interface UpdateActivityRequest {
    id: string;
    activity: Activity;
}

export interface UpdateIntervalRequest {
    id: string;
    intervalId: number;
    interval: Interval;
}

export interface UpdateIntervalsRequest {
    id: string;
    interval: Array<Interval>;
    all?: boolean;
}

export interface UploadActivityRequest {
    id: string;
    name?: string;
    description?: string;
    pairedEventId?: number;
}

/**
 * 
 */
export class ActivitiesApi extends runtime.BaseAPI {

    /**
     * Create a manual activity
     */
    async createManualActivityRaw(requestParameters: CreateManualActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Activity>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createManualActivity().'
            );
        }

        if (requestParameters['activity'] == null) {
            throw new runtime.RequiredError(
                'activity',
                'Required parameter "activity" was null or undefined when calling createManualActivity().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities/manual`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ActivityToJSON(requestParameters['activity']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivityFromJSON(jsonValue));
    }

    /**
     * Create a manual activity
     */
    async createManualActivity(requestParameters: CreateManualActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Activity> {
        const response = await this.createManualActivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an activity
     */
    async deleteActivityRaw(requestParameters: DeleteActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActivityId>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteActivity().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivityIdFromJSON(jsonValue));
    }

    /**
     * Delete an activity
     */
    async deleteActivity(requestParameters: DeleteActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActivityId> {
        const response = await this.deleteActivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete intervals
     */
    async deleteIntervalsRaw(requestParameters: DeleteIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IntervalsDTO>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteIntervals().'
            );
        }

        if (requestParameters['interval'] == null) {
            throw new runtime.RequiredError(
                'interval',
                'Required parameter "interval" was null or undefined when calling deleteIntervals().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/delete-intervals`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['interval']!.map(IntervalToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntervalsDTOFromJSON(jsonValue));
    }

    /**
     * Delete intervals
     */
    async deleteIntervals(requestParameters: DeleteIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IntervalsDTO> {
        const response = await this.deleteIntervalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download activities as CSV
     */
    async downloadActivitiesAsCSVRaw(requestParameters: DownloadActivitiesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadActivitiesAsCSV().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities.csv`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download activities as CSV
     */
    async downloadActivitiesAsCSV(requestParameters: DownloadActivitiesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadActivitiesAsCSVRaw(requestParameters, initOverrides);
    }

    /**
     * Download original activity file, Strava activities not supported
     */
    async downloadActivityFileRaw(requestParameters: DownloadActivityFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadActivityFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/file`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download original activity file, Strava activities not supported
     */
    async downloadActivityFile(requestParameters: DownloadActivityFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadActivityFileRaw(requestParameters, initOverrides);
    }

    /**
     * Download Intervals.icu generated activity fit file
     */
    async downloadActivityFitFileRaw(requestParameters: DownloadActivityFitFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadActivityFitFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['power'] != null) {
            queryParameters['power'] = requestParameters['power'];
        }

        if (requestParameters['hr'] != null) {
            queryParameters['hr'] = requestParameters['hr'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/fit-file`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download Intervals.icu generated activity fit file
     */
    async downloadActivityFitFile(requestParameters: DownloadActivityFitFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadActivityFitFileRaw(requestParameters, initOverrides);
    }

    /**
     * Download zip of Intervals.icu generated activity fit files
     */
    async downloadActivityFitFilesRaw(requestParameters: DownloadActivityFitFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadActivityFitFiles().'
            );
        }

        if (requestParameters['ids'] == null) {
            throw new runtime.RequiredError(
                'ids',
                'Required parameter "ids" was null or undefined when calling downloadActivityFitFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['power'] != null) {
            queryParameters['power'] = requestParameters['power'];
        }

        if (requestParameters['hr'] != null) {
            queryParameters['hr'] = requestParameters['hr'];
        }

        if (requestParameters['ids'] != null) {
            queryParameters['ids'] = requestParameters['ids'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/download-fit-files`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download zip of Intervals.icu generated activity fit files
     */
    async downloadActivityFitFiles(requestParameters: DownloadActivityFitFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadActivityFitFilesRaw(requestParameters, initOverrides);
    }

    /**
     * One of duration or distance is required
     * Find best efforts in the activity
     */
    async findBestEffortsRaw(requestParameters: FindBestEffortsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BestEfforts>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling findBestEfforts().'
            );
        }

        if (requestParameters['stream'] == null) {
            throw new runtime.RequiredError(
                'stream',
                'Required parameter "stream" was null or undefined when calling findBestEfforts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['duration'] != null) {
            queryParameters['duration'] = requestParameters['duration'];
        }

        if (requestParameters['distance'] != null) {
            queryParameters['distance'] = requestParameters['distance'];
        }

        if (requestParameters['count'] != null) {
            queryParameters['count'] = requestParameters['count'];
        }

        if (requestParameters['minValue'] != null) {
            queryParameters['minValue'] = requestParameters['minValue'];
        }

        if (requestParameters['excludeIntervals'] != null) {
            queryParameters['excludeIntervals'] = requestParameters['excludeIntervals'];
        }

        if (requestParameters['startIndex'] != null) {
            queryParameters['startIndex'] = requestParameters['startIndex'];
        }

        if (requestParameters['endIndex'] != null) {
            queryParameters['endIndex'] = requestParameters['endIndex'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/best-efforts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BestEffortsFromJSON(jsonValue));
    }

    /**
     * One of duration or distance is required
     * Find best efforts in the activity
     */
    async findBestEfforts(requestParameters: FindBestEffortsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BestEfforts> {
        const response = await this.findBestEffortsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch multiple activities by id. Missing activities are ignored
     */
    async getActivitiesRaw(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Activity>>> {
        if (requestParameters['athleteId'] == null) {
            throw new runtime.RequiredError(
                'athleteId',
                'Required parameter "athleteId" was null or undefined when calling getActivities().'
            );
        }

        if (requestParameters['ids'] == null) {
            throw new runtime.RequiredError(
                'ids',
                'Required parameter "ids" was null or undefined when calling getActivities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['intervals'] != null) {
            queryParameters['intervals'] = requestParameters['intervals'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{athleteId}/activities/{ids}`.replace(`{${"athleteId"}}`, encodeURIComponent(String(requestParameters['athleteId']))).replace(`{${"ids"}}`, encodeURIComponent(String(requestParameters['ids']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivityFromJSON));
    }

    /**
     * Fetch multiple activities by id. Missing activities are ignored
     */
    async getActivities(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Activity>> {
        const response = await this.getActivitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an activity
     */
    async getActivityRaw(requestParameters: GetActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetActivityDefaultResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivity().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['intervals'] != null) {
            queryParameters['intervals'] = requestParameters['intervals'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetActivityDefaultResponseFromJSON(jsonValue));
    }

    /**
     * Get an activity
     */
    async getActivity(requestParameters: GetActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetActivityDefaultResponse> {
        const response = await this.getActivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity heart rate curve in JSON or CSV (use .csv ext) format
     */
    async getActivityHRCurveRaw(requestParameters: GetActivityHRCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivityHRCurve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/hr-curve{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get activity heart rate curve in JSON or CSV (use .csv ext) format
     */
    async getActivityHRCurve(requestParameters: GetActivityHRCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getActivityHRCurveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity map data
     */
    async getActivityMapRaw(requestParameters: GetActivityMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapData>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivityMap().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/map`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapDataFromJSON(jsonValue));
    }

    /**
     * Get activity map data
     */
    async getActivityMap(requestParameters: GetActivityMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapData> {
        const response = await this.getActivityMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity pace curve in JSON or CSV (use .csv ext) format
     */
    async getActivityPaceCurveRaw(requestParameters: GetActivityPaceCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivityPaceCurve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['gap'] != null) {
            queryParameters['gap'] = requestParameters['gap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/pace-curve{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get activity pace curve in JSON or CSV (use .csv ext) format
     */
    async getActivityPaceCurve(requestParameters: GetActivityPaceCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getActivityPaceCurveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity power curve in JSON or CSV (use .csv ext) format
     */
    async getActivityPowerCurveRaw(requestParameters: GetActivityPowerCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivityPowerCurve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fatigue'] != null) {
            queryParameters['fatigue'] = requestParameters['fatigue'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/power-curve{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get activity power curve in JSON or CSV (use .csv ext) format
     */
    async getActivityPowerCurve(requestParameters: GetActivityPowerCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getActivityPowerCurveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity power spike detection model
     */
    async getActivityPowerSpikeModelRaw(requestParameters: GetActivityPowerSpikeModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PowerModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivityPowerSpikeModel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/power-spike-model`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PowerModelFromJSON(jsonValue));
    }

    /**
     * Get activity power spike detection model
     */
    async getActivityPowerSpikeModel(requestParameters: GetActivityPowerSpikeModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PowerModel> {
        const response = await this.getActivityPowerSpikeModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity segments
     */
    async getActivitySegmentsRaw(requestParameters: GetActivitySegmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<IcuSegment>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivitySegments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/segments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IcuSegmentFromJSON));
    }

    /**
     * Get activity segments
     */
    async getActivitySegments(requestParameters: GetActivitySegmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<IcuSegment>> {
        const response = await this.getActivitySegmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Note that this endpoint will return \'fixed_watts\' as \'watts\'. If \'raw_watts\' is asked for or types is null then the \'watts\' stream is renamed to \'raw_watts\'. If ext is .csv then CSV data is returned instead of JSON
     * List streams for the activity
     */
    async getActivityStreamsRaw(requestParameters: GetActivityStreamsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ActivityStream>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getActivityStreams().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['types'] != null) {
            queryParameters['types'] = requestParameters['types'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/streams{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivityStreamFromJSON));
    }

    /**
     * Note that this endpoint will return \'fixed_watts\' as \'watts\'. If \'raw_watts\' is asked for or types is null then the \'watts\' stream is renamed to \'raw_watts\'. If ext is .csv then CSV data is returned instead of JSON
     * List streams for the activity
     */
    async getActivityStreams(requestParameters: GetActivityStreamsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ActivityStream>> {
        const response = await this.getActivityStreamsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the power model used to resolve %MMP steps in workouts for the athlete
     */
    async getAthleteMMPModelRaw(requestParameters: GetAthleteMMPModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PowerModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getAthleteMMPModel().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling getAthleteMMPModel().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/mmp-model`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PowerModelFromJSON(jsonValue));
    }

    /**
     * Get the power model used to resolve %MMP steps in workouts for the athlete
     */
    async getAthleteMMPModel(requestParameters: GetAthleteMMPModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PowerModel> {
        const response = await this.getAthleteMMPModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity gradient adjusted pace histogram
     */
    async getGapHistogramRaw(requestParameters: GetGapHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Bucket>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getGapHistogram().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/gap-histogram`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BucketFromJSON));
    }

    /**
     * Get activity gradient adjusted pace histogram
     */
    async getGapHistogram(requestParameters: GetGapHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Bucket>> {
        const response = await this.getGapHistogramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity heart rate histogram
     */
    async getHRHistogramRaw(requestParameters: GetHRHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Bucket>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getHRHistogram().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bucketSize'] != null) {
            queryParameters['bucketSize'] = requestParameters['bucketSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/hr-histogram`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BucketFromJSON));
    }

    /**
     * Get activity heart rate histogram
     */
    async getHRHistogram(requestParameters: GetHRHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Bucket>> {
        const response = await this.getHRHistogramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity heart rate training load model
     */
    async getHRTrainingLoadModelRaw(requestParameters: GetHRTrainingLoadModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HRLoadModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getHRTrainingLoadModel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/hr-load-model`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HRLoadModelFromJSON(jsonValue));
    }

    /**
     * Get activity heart rate training load model
     */
    async getHRTrainingLoadModel(requestParameters: GetHRTrainingLoadModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HRLoadModel> {
        const response = await this.getHRTrainingLoadModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return interval like stats for part of the activity
     */
    async getIntervalStatsRaw(requestParameters: GetIntervalStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Interval>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getIntervalStats().'
            );
        }

        if (requestParameters['startIndex'] == null) {
            throw new runtime.RequiredError(
                'startIndex',
                'Required parameter "startIndex" was null or undefined when calling getIntervalStats().'
            );
        }

        if (requestParameters['endIndex'] == null) {
            throw new runtime.RequiredError(
                'endIndex',
                'Required parameter "endIndex" was null or undefined when calling getIntervalStats().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startIndex'] != null) {
            queryParameters['start_index'] = requestParameters['startIndex'];
        }

        if (requestParameters['endIndex'] != null) {
            queryParameters['end_index'] = requestParameters['endIndex'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/interval-stats`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntervalFromJSON(jsonValue));
    }

    /**
     * Return interval like stats for part of the activity
     */
    async getIntervalStats(requestParameters: GetIntervalStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Interval> {
        const response = await this.getIntervalStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity intervals
     */
    async getIntervalsRaw(requestParameters: GetIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IntervalsDTO>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getIntervals().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/intervals`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntervalsDTOFromJSON(jsonValue));
    }

    /**
     * Get activity intervals
     */
    async getIntervals(requestParameters: GetIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IntervalsDTO> {
        const response = await this.getIntervalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity pace histogram
     */
    async getPaceHistogramRaw(requestParameters: GetPaceHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Bucket>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPaceHistogram().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/pace-histogram`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BucketFromJSON));
    }

    /**
     * Get activity pace histogram
     */
    async getPaceHistogram(requestParameters: GetPaceHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Bucket>> {
        const response = await this.getPaceHistogramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the athlete\'s power vs heart rate curve for a date range
     */
    async getPowerHRCurveRaw(requestParameters: GetPowerHRCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PowerHRCurve>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPowerHRCurve().'
            );
        }

        if (requestParameters['start'] == null) {
            throw new runtime.RequiredError(
                'start',
                'Required parameter "start" was null or undefined when calling getPowerHRCurve().'
            );
        }

        if (requestParameters['end'] == null) {
            throw new runtime.RequiredError(
                'end',
                'Required parameter "end" was null or undefined when calling getPowerHRCurve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['end'] != null) {
            queryParameters['end'] = requestParameters['end'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/power-hr-curve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PowerHRCurveFromJSON(jsonValue));
    }

    /**
     * Get the athlete\'s power vs heart rate curve for a date range
     */
    async getPowerHRCurve(requestParameters: GetPowerHRCurveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PowerHRCurve> {
        const response = await this.getPowerHRCurveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity power histogram
     */
    async getPowerHistogramRaw(requestParameters: GetPowerHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Bucket>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPowerHistogram().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bucketSize'] != null) {
            queryParameters['bucketSize'] = requestParameters['bucketSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/power-histogram`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BucketFromJSON));
    }

    /**
     * Get activity power histogram
     */
    async getPowerHistogram(requestParameters: GetPowerHistogramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Bucket>> {
        const response = await this.getPowerHistogramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity power vs heart rate data in JSON or CSV (use .csv ext) format
     */
    async getPowerVsHRRaw(requestParameters: GetPowerVsHRRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PowerVsHRPlot>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPowerVsHR().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/power-vs-hr{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PowerVsHRPlotFromJSON(jsonValue));
    }

    /**
     * Get activity power vs heart rate data in JSON or CSV (use .csv ext) format
     */
    async getPowerVsHR(requestParameters: GetPowerVsHRRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PowerVsHRPlot> {
        const response = await this.getPowerVsHRRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get activity time at heart rate data
     */
    async getTimeAtHRRaw(requestParameters: GetTimeAtHRRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Plot>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getTimeAtHR().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/time-at-hr`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlotFromJSON(jsonValue));
    }

    /**
     * Get activity time at heart rate data
     */
    async getTimeAtHR(requestParameters: GetTimeAtHRRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Plot> {
        const response = await this.getTimeAtHRRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List activities for a date range
     */
    async listActivitiesRaw(requestParameters: ListActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Activity>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listActivities().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling listActivities().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling listActivities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivityFromJSON));
    }

    /**
     * List activities for a date range
     */
    async listActivities(requestParameters: ListActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Activity>> {
        const response = await this.listActivitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use ext of .csv to get results in CSV format
     * Get best HR for a range of durations for matching activities in the date range
     */
    async listActivityHRCurvesRaw(requestParameters: ListActivityHRCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActivityHRCurvePayload>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listActivityHRCurves().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling listActivityHRCurves().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling listActivityHRCurves().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        if (requestParameters['secs'] != null) {
            queryParameters['secs'] = requestParameters['secs'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activity-hr-curves{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivityHRCurvePayloadFromJSON(jsonValue));
    }

    /**
     * Use ext of .csv to get results in CSV format
     * Get best HR for a range of durations for matching activities in the date range
     */
    async listActivityHRCurves(requestParameters: ListActivityHRCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActivityHRCurvePayload> {
        const response = await this.listActivityHRCurvesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use ext of .csv to get results in CSV format
     * Get best pace for a range of distances for matching activities in the date range
     */
    async listActivityPaceCurvesRaw(requestParameters: ListActivityPaceCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listActivityPaceCurves().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling listActivityPaceCurves().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling listActivityPaceCurves().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        if (requestParameters['distances'] != null) {
            queryParameters['distances'] = requestParameters['distances'];
        }

        if (requestParameters['gap'] != null) {
            queryParameters['gap'] = requestParameters['gap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activity-pace-curves{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use ext of .csv to get results in CSV format
     * Get best pace for a range of distances for matching activities in the date range
     */
    async listActivityPaceCurves(requestParameters: ListActivityPaceCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listActivityPaceCurvesRaw(requestParameters, initOverrides);
    }

    /**
     * Use ext of .csv to get results in CSV format
     * Get best power for a range of durations for matching activities in the date range
     */
    async listActivityPowerCurvesRaw(requestParameters: ListActivityPowerCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActivityPowerCurvePayload>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listActivityPowerCurves().'
            );
        }

        if (requestParameters['oldest'] == null) {
            throw new runtime.RequiredError(
                'oldest',
                'Required parameter "oldest" was null or undefined when calling listActivityPowerCurves().'
            );
        }

        if (requestParameters['newest'] == null) {
            throw new runtime.RequiredError(
                'newest',
                'Required parameter "newest" was null or undefined when calling listActivityPowerCurves().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['oldest'] != null) {
            queryParameters['oldest'] = requestParameters['oldest'];
        }

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        if (requestParameters['secs'] != null) {
            queryParameters['secs'] = requestParameters['secs'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['fatigue'] != null) {
            queryParameters['fatigue'] = requestParameters['fatigue'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activity-power-curves{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivityPowerCurvePayloadFromJSON(jsonValue));
    }

    /**
     * Use ext of .csv to get results in CSV format
     * Get best power for a range of durations for matching activities in the date range
     */
    async listActivityPowerCurves(requestParameters: ListActivityPowerCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActivityPowerCurvePayload> {
        const response = await this.listActivityPowerCurvesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Curves are specified as follows: 1y (past year), 2y (past 2 years) etc., 42d (past 42 days) etc., s0 (current season), s1 (previous season) etc., all (all time), r.2023-10-01.2023-10-31 (date range)
     * List best heart rate curves for the athlete
     */
    async listAthleteHRCurvesRaw(requestParameters: ListAthleteHRCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataCurveSetHRCurve>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listAthleteHRCurves().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['curves'] != null) {
            queryParameters['curves'] = requestParameters['curves'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['subMaxEfforts'] != null) {
            queryParameters['subMaxEfforts'] = requestParameters['subMaxEfforts'];
        }

        if (requestParameters['now'] != null) {
            queryParameters['now'] = requestParameters['now'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/hr-curves{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataCurveSetHRCurveFromJSON(jsonValue));
    }

    /**
     * Curves are specified as follows: 1y (past year), 2y (past 2 years) etc., 42d (past 42 days) etc., s0 (current season), s1 (previous season) etc., all (all time), r.2023-10-01.2023-10-31 (date range)
     * List best heart rate curves for the athlete
     */
    async listAthleteHRCurves(requestParameters: ListAthleteHRCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataCurveSetHRCurve> {
        const response = await this.listAthleteHRCurvesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Curves are specified as follows: 1y (past year), 2y (past 2 years) etc., 42d (past 42 days) etc., s0 (current season), s1 (previous season) etc., all (all time), r.2023-10-01.2023-10-31 (date range)
     * List best pace curves for the athlete
     */
    async listAthletePaceCurvesRaw(requestParameters: ListAthletePaceCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataCurveSetPaceCurve>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listAthletePaceCurves().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['curves'] != null) {
            queryParameters['curves'] = requestParameters['curves'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['includeRanks'] != null) {
            queryParameters['includeRanks'] = requestParameters['includeRanks'];
        }

        if (requestParameters['subMaxEfforts'] != null) {
            queryParameters['subMaxEfforts'] = requestParameters['subMaxEfforts'];
        }

        if (requestParameters['now'] != null) {
            queryParameters['now'] = requestParameters['now'];
        }

        if (requestParameters['gap'] != null) {
            queryParameters['gap'] = requestParameters['gap'];
        }

        if (requestParameters['pmType'] != null) {
            queryParameters['pmType'] = requestParameters['pmType'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/pace-curves{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataCurveSetPaceCurveFromJSON(jsonValue));
    }

    /**
     * Curves are specified as follows: 1y (past year), 2y (past 2 years) etc., 42d (past 42 days) etc., s0 (current season), s1 (previous season) etc., all (all time), r.2023-10-01.2023-10-31 (date range)
     * List best pace curves for the athlete
     */
    async listAthletePaceCurves(requestParameters: ListAthletePaceCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataCurveSetPaceCurve> {
        const response = await this.listAthletePaceCurvesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Curves are specified as follows: 1y (past year), 2y (past 2 years) etc., 42d (past 42 days) etc., s0 (current season), s1 (previous season) etc., all (all time), r.2023-10-01.2023-10-31 (date range). Curves can also have a -kj0 or -kj1 suffix to return fatigued curves
     * List best power curves for the athlete
     */
    async listAthletePowerCurvesRaw(requestParameters: ListAthletePowerCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataCurveSetPowerCurve>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listAthletePowerCurves().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling listAthletePowerCurves().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['newest'] != null) {
            queryParameters['newest'] = requestParameters['newest'];
        }

        if (requestParameters['curves'] != null) {
            queryParameters['curves'] = requestParameters['curves'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['includeRanks'] != null) {
            queryParameters['includeRanks'] = requestParameters['includeRanks'];
        }

        if (requestParameters['subMaxEfforts'] != null) {
            queryParameters['subMaxEfforts'] = requestParameters['subMaxEfforts'];
        }

        if (requestParameters['now'] != null) {
            queryParameters['now'] = requestParameters['now'];
        }

        if (requestParameters['pmType'] != null) {
            queryParameters['pmType'] = requestParameters['pmType'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/power-curves{ext}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataCurveSetPowerCurveFromJSON(jsonValue));
    }

    /**
     * Curves are specified as follows: 1y (past year), 2y (past 2 years) etc., 42d (past 42 days) etc., s0 (current season), s1 (previous season) etc., all (all time), r.2023-10-01.2023-10-31 (date range). Curves can also have a -kj0 or -kj1 suffix to return fatigued curves
     * List best power curves for the athlete
     */
    async listAthletePowerCurves(requestParameters: ListAthletePowerCurvesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataCurveSetPowerCurve> {
        const response = await this.listAthletePowerCurvesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all tags that have been applied to the athlete\'s activities
     */
    async listTags2Raw(requestParameters: ListTags2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listTags2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activity-tags`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List all tags that have been applied to the athlete\'s activities
     */
    async listTags2(requestParameters: ListTags2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.listTags2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for activities by name or tag, returns summary info
     */
    async searchForActivitiesRaw(requestParameters: SearchForActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ActivitySearchResult>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling searchForActivities().'
            );
        }

        if (requestParameters['q'] == null) {
            throw new runtime.RequiredError(
                'q',
                'Required parameter "q" was null or undefined when calling searchForActivities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities/search`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivitySearchResultFromJSON));
    }

    /**
     * Search for activities by name or tag, returns summary info
     */
    async searchForActivities(requestParameters: SearchForActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ActivitySearchResult>> {
        const response = await this.searchForActivitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for activities by name or tag, returns full activities
     */
    async searchForActivitiesFullRaw(requestParameters: SearchForActivitiesFullRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Activity>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling searchForActivitiesFull().'
            );
        }

        if (requestParameters['q'] == null) {
            throw new runtime.RequiredError(
                'q',
                'Required parameter "q" was null or undefined when calling searchForActivitiesFull().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities/search-full`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivityFromJSON));
    }

    /**
     * Search for activities by name or tag, returns full activities
     */
    async searchForActivitiesFull(requestParameters: SearchForActivitiesFullRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Activity>> {
        const response = await this.searchForActivitiesFullRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Activities returned most recent first
     * Find activities with intervals matching duration and intensity
     */
    async searchForIntervalsRaw(requestParameters: SearchForIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Activity>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling searchForIntervals().'
            );
        }

        if (requestParameters['minSecs'] == null) {
            throw new runtime.RequiredError(
                'minSecs',
                'Required parameter "minSecs" was null or undefined when calling searchForIntervals().'
            );
        }

        if (requestParameters['maxSecs'] == null) {
            throw new runtime.RequiredError(
                'maxSecs',
                'Required parameter "maxSecs" was null or undefined when calling searchForIntervals().'
            );
        }

        if (requestParameters['minIntensity'] == null) {
            throw new runtime.RequiredError(
                'minIntensity',
                'Required parameter "minIntensity" was null or undefined when calling searchForIntervals().'
            );
        }

        if (requestParameters['maxIntensity'] == null) {
            throw new runtime.RequiredError(
                'maxIntensity',
                'Required parameter "maxIntensity" was null or undefined when calling searchForIntervals().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['minSecs'] != null) {
            queryParameters['minSecs'] = requestParameters['minSecs'];
        }

        if (requestParameters['maxSecs'] != null) {
            queryParameters['maxSecs'] = requestParameters['maxSecs'];
        }

        if (requestParameters['minIntensity'] != null) {
            queryParameters['minIntensity'] = requestParameters['minIntensity'];
        }

        if (requestParameters['maxIntensity'] != null) {
            queryParameters['maxIntensity'] = requestParameters['maxIntensity'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['minReps'] != null) {
            queryParameters['minReps'] = requestParameters['minReps'];
        }

        if (requestParameters['maxReps'] != null) {
            queryParameters['maxReps'] = requestParameters['maxReps'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities/interval-search`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActivityFromJSON));
    }

    /**
     * Activities returned most recent first
     * Find activities with intervals matching duration and intensity
     */
    async searchForIntervals(requestParameters: SearchForIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Activity>> {
        const response = await this.searchForIntervalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Split an interval
     */
    async splitIntervalRaw(requestParameters: SplitIntervalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IntervalsDTO>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling splitInterval().'
            );
        }

        if (requestParameters['splitAt'] == null) {
            throw new runtime.RequiredError(
                'splitAt',
                'Required parameter "splitAt" was null or undefined when calling splitInterval().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['splitAt'] != null) {
            queryParameters['splitAt'] = requestParameters['splitAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/split-interval`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntervalsDTOFromJSON(jsonValue));
    }

    /**
     * Split an interval
     */
    async splitInterval(requestParameters: SplitIntervalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IntervalsDTO> {
        const response = await this.splitIntervalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update activity
     */
    async updateActivityRaw(requestParameters: UpdateActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Activity>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateActivity().'
            );
        }

        if (requestParameters['activity'] == null) {
            throw new runtime.RequiredError(
                'activity',
                'Required parameter "activity" was null or undefined when calling updateActivity().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ActivityToJSON(requestParameters['activity']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivityFromJSON(jsonValue));
    }

    /**
     * Update activity
     */
    async updateActivity(requestParameters: UpdateActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Activity> {
        const response = await this.updateActivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update/create an interval
     */
    async updateIntervalRaw(requestParameters: UpdateIntervalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IntervalsDTO>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateInterval().'
            );
        }

        if (requestParameters['intervalId'] == null) {
            throw new runtime.RequiredError(
                'intervalId',
                'Required parameter "intervalId" was null or undefined when calling updateInterval().'
            );
        }

        if (requestParameters['interval'] == null) {
            throw new runtime.RequiredError(
                'interval',
                'Required parameter "interval" was null or undefined when calling updateInterval().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/intervals/{intervalId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"intervalId"}}`, encodeURIComponent(String(requestParameters['intervalId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IntervalToJSON(requestParameters['interval']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntervalsDTOFromJSON(jsonValue));
    }

    /**
     * Update/create an interval
     */
    async updateInterval(requestParameters: UpdateIntervalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IntervalsDTO> {
        const response = await this.updateIntervalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update intervals for an activity
     */
    async updateIntervalsRaw(requestParameters: UpdateIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IntervalsDTO>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateIntervals().'
            );
        }

        if (requestParameters['interval'] == null) {
            throw new runtime.RequiredError(
                'interval',
                'Required parameter "interval" was null or undefined when calling updateIntervals().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/activity/{id}/intervals`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['interval']!.map(IntervalToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntervalsDTOFromJSON(jsonValue));
    }

    /**
     * Update intervals for an activity
     */
    async updateIntervals(requestParameters: UpdateIntervalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IntervalsDTO> {
        const response = await this.updateIntervalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Multisport files are split into multiple activities. Activities are de-duped using a hash of the file. Response code is 201 if at least one new actvity was created and 200 otherwise (all dups).
     * Create new activities from an uploaded file (fit, tcx, gpx or zip or gz of the same) as multipart/form-data
     */
    async uploadActivityRaw(requestParameters: UploadActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling uploadActivity().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['description'] != null) {
            queryParameters['description'] = requestParameters['description'];
        }

        if (requestParameters['pairedEventId'] != null) {
            queryParameters['paired_event_id'] = requestParameters['pairedEventId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("AccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/athlete/{id}/activities`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadResponseFromJSON(jsonValue));
    }

    /**
     * Multisport files are split into multiple activities. Activities are de-duped using a hash of the file. Response code is 201 if at least one new actvity was created and 200 otherwise (all dups).
     * Create new activities from an uploaded file (fit, tcx, gpx or zip or gz of the same) as multipart/form-data
     */
    async uploadActivity(requestParameters: UploadActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadResponse> {
        const response = await this.uploadActivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAthleteMMPModelTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type GetAthleteMMPModelTypeEnum = typeof GetAthleteMMPModelTypeEnum[keyof typeof GetAthleteMMPModelTypeEnum];
/**
 * @export
 */
export const ListActivityHRCurvesTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ListActivityHRCurvesTypeEnum = typeof ListActivityHRCurvesTypeEnum[keyof typeof ListActivityHRCurvesTypeEnum];
/**
 * @export
 */
export const ListActivityPaceCurvesTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ListActivityPaceCurvesTypeEnum = typeof ListActivityPaceCurvesTypeEnum[keyof typeof ListActivityPaceCurvesTypeEnum];
/**
 * @export
 */
export const ListActivityPowerCurvesTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ListActivityPowerCurvesTypeEnum = typeof ListActivityPowerCurvesTypeEnum[keyof typeof ListActivityPowerCurvesTypeEnum];
/**
 * @export
 */
export const ListAthleteHRCurvesTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ListAthleteHRCurvesTypeEnum = typeof ListAthleteHRCurvesTypeEnum[keyof typeof ListAthleteHRCurvesTypeEnum];
/**
 * @export
 */
export const ListAthletePaceCurvesTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ListAthletePaceCurvesTypeEnum = typeof ListAthletePaceCurvesTypeEnum[keyof typeof ListAthletePaceCurvesTypeEnum];
/**
 * @export
 */
export const ListAthletePaceCurvesPmTypeEnum = {
    Cs: 'CS'
} as const;
export type ListAthletePaceCurvesPmTypeEnum = typeof ListAthletePaceCurvesPmTypeEnum[keyof typeof ListAthletePaceCurvesPmTypeEnum];
/**
 * @export
 */
export const ListAthletePowerCurvesTypeEnum = {
    Ride: 'Ride',
    Run: 'Run',
    Swim: 'Swim',
    WeightTraining: 'WeightTraining',
    Hike: 'Hike',
    Walk: 'Walk',
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    EMountainBikeRide: 'EMountainBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hockey: 'Hockey',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    OpenWaterSwim: 'OpenWaterSwim',
    Padel: 'Padel',
    Pilates: 'Pilates',
    Pickleball: 'Pickleball',
    Racquetball: 'Racquetball',
    Rugby: 'Rugby',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Transition: 'Transition',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    WaterSport: 'WaterSport',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga',
    Other: 'Other'
} as const;
export type ListAthletePowerCurvesTypeEnum = typeof ListAthletePowerCurvesTypeEnum[keyof typeof ListAthletePowerCurvesTypeEnum];
/**
 * @export
 */
export const ListAthletePowerCurvesPmTypeEnum = {
    Ms2P: 'MS_2P',
    Morton3P: 'MORTON_3P',
    FftCurves: 'FFT_CURVES',
    Ecp: 'ECP'
} as const;
export type ListAthletePowerCurvesPmTypeEnum = typeof ListAthletePowerCurvesPmTypeEnum[keyof typeof ListAthletePowerCurvesPmTypeEnum];
/**
 * @export
 */
export const SearchForIntervalsTypeEnum = {
    Auto: 'AUTO',
    Power: 'POWER',
    Hr: 'HR',
    Pace: 'PACE'
} as const;
export type SearchForIntervalsTypeEnum = typeof SearchForIntervalsTypeEnum[keyof typeof SearchForIntervalsTypeEnum];
